/**
 * Arduino EEPROM Programmer
 * Set up for Atmel AT28C64B EEPROM
 * Can read and write a byte of data to a given memory location.
 * Contents is outputted via serial pins.
 * 
 * Program used 2 x 74595 Shift registers to minimise number of pins required.
 */
#define SHIFT_DATA 2
#define SHIFT_CLK 3
#define SHIFT_LATCH 4
#define EEPROM_D0 5
#define EEPROM_D7 12
#define WRITE_EN 13

//#define MAX_ADDRESS 0x1fff //13 address lines 0 - 8192
#define MAX_ADDRESS 0x7fff //15 address lines 0 - 32767

/*
 * Set up steps. The EEPROM is written or read in the set up
 */
void setup() 
{
   pinMode(SHIFT_DATA, OUTPUT);
   pinMode(SHIFT_CLK, OUTPUT);
   pinMode(SHIFT_LATCH, OUTPUT);  
   
   digitalWrite(WRITE_EN, HIGH);
   pinMode(WRITE_EN, OUTPUT);
   
   Serial.begin(57600);

   for( int i = 0; i < 512; i++ )
   {
       writeEEprom(i, 0xea);
   }

  // program - longhand hello world 
  // byte program[] = { 0xa9, 0xff, 0x8d, 0x02, 0x60, 0xa9, 0xe0, 0x8d, 0x03, 0x60, 0xa9, 0x38, 0x8d, 0x00, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x80, 0x8d, 0x01, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x0e, 0x8d, 0x00, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x80, 0x8d, 0x01, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x06, 0x8d, 0x00, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x80, 0x8d, 0x01, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x48, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x65, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x6c, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x6c, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x6f, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x2c, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x77, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x6f, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x72, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x6c, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x64, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0x21, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0x4c, 0x4a, 0x01 };

    // with sub routines
   //byte program[] = { 0xa2,0xff,0x9a,0xa9,0xff,0x8d,0x02,0x60,0xa9,0xe0,0x8d,0x03,0x60,0xa9,0x38,0x20,0x60,0x80,0xa9,0x0e,0x20,0x60,0x80,0xa9,0x06,0x20,0x60,0x80,0xa9,0x48,0x20,0x73,0x80,0xa9,0x65,0x20,0x73,0x80,0xa9,0x6c,0x20,0x73,0x80,0xa9,0x6c,0x20,0x73,0x80,0xa9,0x6f,0x20,0x73,0x80,0xa9,0x2c,0x20,0x73,0x80,0xa9,0x20,0x20,0x73,0x80,0xa9,0x77,0x20,0x73,0x80,0xa9,0x6f,0x20,0x73,0x80,0xa9,0x72,0x20,0x73,0x80,0xa9,0x6c,0x20,0x73,0x80,0xa9,0x64,0x20,0x73,0x80,0xa9,0x21,0x20,0x73,0x80,0x4c,0x5d,0x80,0x8d,0x00,0x60,0xa9,0x00,0x8d,0x01,0x60,0xa9,0x80,0x8d,0x01,0x60,0xa9,0x00,0x8d,0x01,0x60,0x60,0x8d,0x00,0x60,0xa9,0x20,0x8d,0x01,0x60,0xa9,0xa0,0x8d,0x01,0x60,0xa9,0x20,0x8d,0x01,0x60,0x60 };

   // for 16mhz crystal with busy flag detection
   //byte program[] = { 0xa2, 0xff, 0x9a, 0xa9, 0xff, 0x8d, 0x02, 0x60, 0xa9, 0xe0, 0x8d, 0x03, 0x60, 0xa9, 0x38, 0x20, 0x88, 0x80, 0xa9, 0x0e, 0x20, 0x88, 0x80, 0xa9, 0x06, 0x20, 0x88, 0x80, 0xa9, 0x01, 0x20, 0x88, 0x80, 0xa9, 0x48, 0x20, 0x9e, 0x80, 0xa9, 0x65, 0x20, 0x9e, 0x80, 0xa9, 0x6c, 0x20, 0x9e, 0x80, 0xa9, 0x6c, 0x20, 0x9e, 0x80, 0xa9, 0x6f, 0x20, 0x9e, 0x80, 0xa9, 0x2c, 0x20, 0x9e, 0x80, 0xa9, 0x20, 0x20, 0x9e, 0x80, 0xa9, 0x77, 0x20, 0x9e, 0x80, 0xa9, 0x6f, 0x20, 0x9e, 0x80, 0xa9, 0x72, 0x20, 0x9e, 0x80, 0xa9, 0x6c, 0x20, 0x9e, 0x80, 0xa9, 0x64, 0x20, 0x9e, 0x80, 0xa9, 0x21, 0x20, 0x9e, 0x80, 0x4c, 0x62, 0x80, 0x48, 0xa9, 0x00, 0x8d, 0x02, 0x60, 0xa9, 0x40, 0x8d, 0x01, 0x60, 0xa9, 0xc0, 0x8d, 0x01, 0x60, 0xad, 0x00, 0x60, 0x29, 0x80, 0xd0, 0xef, 0xa9, 0x40, 0x8d, 0x01, 0x60, 0xa9, 0xff, 0x8d, 0x02, 0x60, 0x68, 0x60, 0x20, 0x65, 0x80, 0x8d, 0x00, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x80, 0x8d, 0x01, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0x60, 0x20, 0x65, 0x80, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0x60 };   

   byte program[] = { 0xa2, 0xff, 0x9a, 0xa9, 0xff, 0x8d, 0x02, 0x60, 0xa9, 0xe0, 0x8d, 0x03, 0x60, 0xa9, 0x38, 0x20, 0x8c, 0x80, 0xa9, 0x0e, 0x20, 0x8c, 0x80, 0xa9, 0x06, 0x20, 0x8c, 0x80, 0xa9, 0x01, 0x20, 0x8c, 0x80, 0xa2, 0x00, 0xbd, 0x32, 0x80, 0xf0, 0x07, 0x20, 0xa2, 0x80, 0xe8, 0x4c, 0x23, 0x80, 0x4c, 0x2f, 0x80, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x36, 0x35, 0x30, 0x32, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x6f, 0x72, 0x00, 0x48, 0xa9, 0x00, 0x8d, 0x02, 0x60, 0xa9, 0x40, 0x8d, 0x01, 0x60, 0xa9, 0xc0, 0x8d, 0x01, 0x60, 0xad, 0x00, 0x60, 0x29, 0x80, 0xd0, 0xef, 0xa9, 0x40, 0x8d, 0x01, 0x60, 0xa9, 0xff, 0x8d, 0x02, 0x60, 0x68, 0x60, 0x20, 0x69, 0x80, 0x8d, 0x00, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0xa9, 0x80, 0x8d, 0x01, 0x60, 0xa9, 0x00, 0x8d, 0x01, 0x60, 0x60, 0x20, 0x69, 0x80, 0x8d, 0x00, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0xa9, 0xa0, 0x8d, 0x01, 0x60, 0xa9, 0x20, 0x8d, 0x01, 0x60, 0x60 };

   int address = 0x00;

   for( int i = 0; i < sizeof(program); i++ )
   {
       writeEEprom(i, program[i]);
   }

   writeEEprom(0x7ffc, 0x00);
   writeEEprom(0xfffd, 0x80);

   printContents(0x0000, 0x0100);
   printContentsAtAddress(0x7ffc);
   printContentsAtAddress(0x7ffd);
   
   /*  
   writeEEprom(0, 0x12);
   writeEEprom(1, 0x34);
   writeEEprom(2, 0x56);
   */

//   for( int address = 0x7FFF; address <= MAX_ADDRESS; address += 1 )
//   {
//       writeEEprom(address, 0xea);
//   } 
//
//   printContents(0x1FFF, MAX_ADDRESS);
    
   //resetEEprom();

   //printContents(0x1FF0, 0x7FFF);
   //printContents(0xff, 0x1ff);

   Serial.println(" ");
//   printContents(0x0ff, 0x7fff);

   //printContents();
   Serial.end();
}

/*
 * Set the address lines and OE pin
 * OE is active low
 * 
 * outputEnabled false - Set OE high to go to input mode 
 * outputEnabled true - Set OE low to go to output mode
 */
void setAddress(int address, bool outputEnable)
{
    // OutputEnable on 2nd 595 pin 7
    shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address >> 8 | (outputEnable ? 0x00 : 0x80));
    shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address);
    
    digitalWrite(SHIFT_LATCH, LOW);
    digitalWrite(SHIFT_LATCH, HIGH);
    digitalWrite(SHIFT_LATCH, LOW); 
}

byte readEEprom(int address)
{
    for( int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1 )
    {
        pinMode(pin, INPUT);
    }
  
    byte data = 0;
    setAddress(address, true);
    for( int pin = EEPROM_D7; pin >= EEPROM_D0; pin -= 1 )
    {
        data = (data << 1) + digitalRead(pin);
    }

    return data;
}

/**
 * Reset memory locations to 0xff
 */
void resetEEprom()
{
    for( int address = 0; address <= MAX_ADDRESS; address += 1 )
    {
        writeEEprom(address, 0xff);
    }  
}

/*
 * Write a byte of data to specified address.
 */
void writeEEprom(int address, byte data)
{
    setAddress(address, false);    

    for( int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1 )
    {
        pinMode(pin, OUTPUT);
    }
        
    for( int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1 )
    {
        digitalWrite(pin, data & 1);
        data = data >> 1;
    }

    digitalWrite(WRITE_EN, LOW);
    delayMicroseconds(1);
    digitalWrite(WRITE_EN, HIGH);
    delay(15);
}

/*
 * Print contents in hex of all memory locations.
 */
void printContents() 
{
    for( int base = 0; base <= MAX_ADDRESS; base += 16 )
    {
       byte data[16];
       for( int offset = 0; offset <= 15; offset += 1)
       {
          data[offset] = readEEprom(base + offset);   
       }

       char buf[80];
       sprintf(buf, "%04x: %02x %02x %02x %02x %02x %02x %02x %02x    %02x %02x %02x %02x %02x %02x %02x %02x", 
       base, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
             data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
       Serial.println(buf);
    }
}

void printContents(int startAddress, int endAddress) 
{
    for( int base = startAddress; base <= endAddress; base += 16 )
    {
       byte data[16];
       for( int offset = 0; offset <= 15; offset += 1)
       {
          data[offset] = readEEprom(base + offset);   
       }

       char buf[80];
       sprintf(buf, "%04x: %02x %02x %02x %02x %02x %02x %02x %02x    %02x %02x %02x %02x %02x %02x %02x %02x", 
       base, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
             data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
       Serial.println(buf);
    }
}

void printContentsAtAddress(int address)
{
   byte b = readEEprom(address);
   char buf[80];
   sprintf(buf, "%04x: %02x", address, b); 
   
   Serial.println(buf);
}

/*
 * Main execution loop.
 */
void loop() 
{
    // Reading and wrting to EEPROM occurs in set up steps
    // as one-off activity 
}
